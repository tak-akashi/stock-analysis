---
description: 計画に基づいて機能を実装（plan-feature完了後に実行）
---

# 機能実装フェーズ (implement-feature)

**目的:** plan-featureで作成した計画に基づいて実装を完了する

**前提条件:**
- `/plan-feature` が完了していること
- `.steering/[日付]-[機能名]/` が存在すること

**引数パターン:**
- `/implement-feature フォルダ名` - `.steering/` 内のフォルダ名を直接指定（推奨）
- `/implement-feature 機能名` - 機能名から該当ディレクトリを検索

**フォルダ名 vs 機能名の判定:**
- `YYYYMMDD-` 形式（例: `20250129-hl-ratio`）で始まる場合 → フォルダ名として直接使用
- それ以外 → 機能名として `.steering/*-[機能名]/` を検索

---

## ステップ1: 前提条件の確認

1. **引数の解析とステアリングディレクトリの特定**

   **フォルダ名が直接指定された場合（`YYYYMMDD-` 形式）:**
   ```
   # フォルダの存在確認
   Glob('.steering/[フォルダ名]/')
   ```

   **機能名が指定された場合（従来の動作）:**
   ```
   # 機能名から該当ディレクトリを検索
   Glob('.steering/*-[機能名]/')
   ```

2. **必須ファイルの存在確認**
   - `requirements.md` が存在するか
   - `design.md` が存在するか
   - `tasklist.md` が存在するか

3. **エラー処理**
   - ディレクトリが見つからない場合:
     ```
     エラー: `.steering/[指定されたフォルダ名または*-機能名]/` が見つかりません。
     先に `/plan-feature [機能名]` を実行してください。
     ```
   - 必須ファイルが欠けている場合:
     ```
     エラー: [ファイル名] が見つかりません。
     `/plan-feature [機能名]` を再実行してください。
     ```

## ステップ2: 計画の読み込み

1. **ステアリングファイルの読み込み**
   ```
   Read('[ステアリングディレクトリ]/requirements.md')
   Read('[ステアリングディレクトリ]/design.md')
   Read('[ステアリングディレクトリ]/tasklist.md')
   ```

2. **タスク一覧の確認**
   - 未完了タスク (`[ ]`) の数を確認
   - 完了済みタスク (`[x]`) の数を確認
   - 進捗率を計算

## ステップ3: テスト作成フェーズ

**目的:** スペック（requirements.md/design.md）に基づいてテストを作成し、実装の検証基盤を整える。

### 3.1 テスト設計

1. **テスト対象の特定**
   - `design.md` から実装予定のクラス/関数を抽出
   - 各クラス/関数に対応するテストケースを設計

2. **テストケースの洗い出し**
   `requirements.md` の受け入れ条件から:
   - 正常系テスト（主要機能の動作確認）
   - 異常系テスト（エラーハンドリング）
   - エッジケース（境界値、空値）

### 3.2 テストファイルの作成

1. **テストファイルの配置**
   ```
   # モジュール: src/[カテゴリ]/[モジュール名].py
   # テスト:    tests/test_[モジュール名].py

   例:
   src/models/upstage/layout.py → tests/test_upstage.py
   src/postprocess/azure.py → tests/test_postprocess_azure.py
   ```

2. **テストの雛形作成**
   `docs/core/development-guidelines.md` のテストパターンに従い、テストファイルを作成:
   - クラスごとにテストクラスを作成
   - 各テストメソッドに明確なdocstringを付与
   - 必要なモック/フィクスチャを設定

3. **テストの実行確認**
   ```bash
   Bash('uv run pytest tests/test_[モジュール名].py -v')
   ```
   - この段階ではテストは**失敗してOK**（実装がまだないため）
   - テストが正しく認識されることを確認

### 3.3 テスト作成の完了条件

- [ ] 全ての主要クラス/関数に対応するテストファイルが存在する
- [ ] 正常系・異常系・エッジケースのテストが設計されている
- [ ] テストが pytest で認識される（実行可能な状態）

---

## ステップ4: 実装ループ (tasklist.mdの完全消化)

**このステップは、`tasklist.md`の全タスクが `[x]` になるまで自動で繰り返されるループ処理です。**

**ループ開始:**

1. **タスクリストの読み込み**
   - `[ステアリングディレクトリ]/tasklist.md`ファイルを読み込む。

2. **進捗の確認**
   - ファイル内に未完了タスク (`[ ]`) が存在するか確認する。
   - **もし未完了タスクが存在しない場合:** この実装ループは完了とみなし、ただちに**ステップ5**へ進む。
   - **もし未完了タスクが存在する場合:** 次の処理（3. タスクの実行）に進む。

3. **タスクの実行**
   - `tasklist.md`の**先頭にある未完了タスク**を1つ特定する。
   - そのタスクを完了させるために必要な実装作業を実行する。
   - `Skill('steering')`を**実装モード**で使用する。
   - `docs/core/development-guidelines.md`のコーディング規約を常に遵守する。

4. **テスト実行による検証**
   タスク完了後、関連するテストを実行して実装を検証する:

   ```bash
   # 関連テストの実行
   Bash('uv run pytest tests/test_[モジュール名].py -v')
   ```

   **テスト結果に応じた対応:**
   - **全テストPASS:** 次のステップ（5. タスクリストの更新）へ進む
   - **テスト失敗:** 失敗したテストが通るまで実装を修正し、再度テストを実行
   - **新しいエッジケース発見:** 必要に応じてテストを追加

5. **タスクリストの更新**
   - テストがPASSしたら、`Edit`ツールを使用して`tasklist.md`を更新し、該当タスクを `[ ]` から `[x]` に変更する。

6. **ループ継続**
   - **ステップ4の先頭 (1. タスクリストの読み込み) に戻り、処理を繰り返す。**

---

### ※ 実装ループ内の例外処理ルール ※

実装ループの実行中に以下の状況が発生した場合は、このルールに従って自律的に対処し、ループを継続すること。

- **ルールA: タスクが大きすぎる場合**
  - **対処法:** 現在のタスクをより小さな複数のサブタスクに分割する。`Edit`ツールを使い、元のタスクを削除し、その場所に新しいサブタスク（`[ ]`付き）を挿入する。その後、ループを継続する。

- **ルールB: 技術的理由でタスクが不要になった場合**
  - **条件:** 実装方針の変更、アーキテクチャの変更、依存関係の変更など、明確な技術的理由がある場合にのみ適用。
  - **対処法:** `Edit`ツールを使い、該当タスクを `[x] ~~タスク名~~ (理由: [具体的な技術的理由を簡潔に記述])` の形式で更新する。その後、ループを継続する。

- **禁止事項:**
  - 未完了タスクを「後でやる」「別タスクにする」などの理由で意図的にスキップすること。
  - 理由なく未完了タスクを放置してループを終了させること。
  - ユーザーに判断を仰ぐこと。

---

## ステップ5: 実装検証

1. **tasklist.mdの全タスク完了を確認**
   - 未完了タスクが0件であることを確認

2. **品質検証（サブエージェント起動）**
   `Task`ツールを使用し、品質を検証する:
   - `subagent_type`: "general-purpose"
   - `description`: "Implementation quality validation"
   - `prompt`: "今回実装した `[機能名]` に関する全ての変更点の品質を検証してください。対象ファイルは `[実装したファイルのパスリスト]` です。コーディング規約、エラーハンドリング、テスト可能性、既存パターンとの整合性を重点的に確認してください。"

## ステップ6: 静的解析と全体テスト

1. **静的解析の実行**
   ```bash
   Bash('uv run ruff check .')
   Bash('uv run mypy src/')
   ```

2. **全テストの実行**
   ```bash
   Bash('uv run pytest tests/ -v')
   ```

3. **エラー対応**
   いずれかのコマンドでエラーが発生した場合は、問題を分析し、修正コードを生成・適用してから、再度このステップを実行する。

## ステップ7: 振り返りとドキュメント更新

1. **振り返りの記録**
   `Skill('steering')`を**振り返りモード**で実行し、`tasklist.md`に申し送り事項を記載する:
   - 実装完了日
   - 計画と実績の差分
   - 学んだこと
   - 次回への改善提案

2. **アーキテクチャ影響の判断**
   今回の変更がプロジェクトの基本設計やアーキテクチャに影響を与えるか判断する。

3. **docs/core/ の更新**
   影響がある場合、`docs/core/`内の関連する永続ドキュメントを`Edit`ツールで更新する:
   - `architecture.md` - 新しいコンポーネントやデータフローの追加
   - `repository-structure.md` - 新しいファイル/ディレクトリの追加
   - `api-reference.md` - 新しいクラス/関数の追加
   - `diagrams.md` - 新しいシーケンス図やクラス図の追加

   **重要:** docs/core/ は実装完了後にのみ更新すること。未実装の機能を記載してはならない。

4. **アイデアファイルのステータス更新（--from-idea使用時）**
   ```
   Edit('docs/ideas/[ファイル名].md')
   → ステータス: draft → implemented
   → 実装日: YYYY-MM-DD
   → ステアリングディレクトリ: .steering/[日付]-[機能名]/
   ```

## 完了条件

このワークフローは、以下の全ての条件を満たした時点で自動的に完了となる:

- **ステップ3:** テストファイルが作成され、テストケースが設計されている
- **ステップ4:** `tasklist.md`の全てのタスクが完了状態（`[x]`または正当な理由でスキップ）になっている
- **ステップ5:** 品質検証をパスする
- **ステップ6:** `ruff check`, `mypy`, `pytest`の全てのコマンドがエラーなく成功する
- **ステップ7:** `tasklist.md`に申し送り事項が記載されている
- **ステップ7:** 必要に応じて`docs/core/`が更新されている

この完了条件を満たすまで、自律的に思考し、問題解決を行い、作業を継続すること。

---

## 完了メッセージ

実装完了時に以下の情報を出力する:

```
## 実装完了

### 実装した機能
- [機能名]

### 作成/変更したファイル
- [ファイルパスのリスト]

### テスト結果
- pytest: PASS ([N]件のテストが成功)

### 品質チェック結果
- ruff check: PASS
- mypy: PASS

### 更新したドキュメント
- [更新したdocs/core/のファイルリスト]

### ステアリングディレクトリ
- `.steering/[日付]-[機能名]/`

---
実装が完了しました。動作確認をお願いします。
```
